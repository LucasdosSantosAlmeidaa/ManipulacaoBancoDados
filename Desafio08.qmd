---
title: "Desafio08"
format: html
editor: visual
---

```{r}
# =================================================================
# CONFIGURAÇÃO INICIAL
# =================================================================
library(RSQLite)
library(DBI)
library(knitr)

# =================================================================
# CONEXÃO E DIAGNÓSTICO DA ESTRUTURA DO BANCO
# =================================================================
conn <- dbConnect(RSQLite::SQLite(), "database.sqlite3")
cat("=== DIAGNÓSTICO AUTOMÁTICO ===\n")

tabelas <- dbListTables(conn)
cat("Tabelas disponíveis:", paste(tabelas, collapse = ", "), "\n")

# Função para diagnosticar cada tabela
diagnosticar_tabela <- function(nome_tabela) {
  if (!nome_tabela %in% tabelas) {
    cat(sprintf("Tabela '%s' não encontrada\n", nome_tabela))
    return(NULL)
  }
  estrutura <- dbGetQuery(conn, sprintf("PRAGMA table_info(%s)", nome_tabela))
  total <- dbGetQuery(conn, sprintf("SELECT COUNT(*) as total FROM %s", nome_tabela))
  
  cat(sprintf("\n--- %s ---\n", toupper(nome_tabela)))
  cat(sprintf("Colunas: %s\n", paste(estrutura$name, collapse = ", ")))
  cat(sprintf("Registros: %d\n", total$total))
  
  pk <- estrutura[estrutura$pk == 1, "name"]
  if (length(pk) > 0) {
    cat(sprintf("Chave primária: %s\n", pk[1]))
  }
  return(list(estrutura = estrutura, total = total$total, pk = if(length(pk) > 0) pk[1] else NULL))
}

estruturas <- list()
tabelas_principais <- c("subjects", "instructors", "courses", "course_offerings",
                        "grade_distributions", "teachings", "subject_memberships", "sections")
for (tab in tabelas_principais) {
  estruturas[[tab]] <- diagnosticar_tabela(tab)
}

co_key <- "uuid"
cat(sprintf("\n Usando chave para course_offerings: %s\n", co_key))

# Teste de Conectividade
cat("\n=== TESTE DE CONECTIVIDADE ===\n")
test_query <- sprintf("SELECT COUNT(*) as total
FROM course_offerings co
INNER JOIN subject_memberships sm ON co.uuid = sm.course_offering_uuid
LIMIT 1")
tryCatch({
  test_result <- dbGetQuery(conn, test_query)
  cat(sprintf("Conectividade OK: %d registros vinculados\n", test_result$total))
}, error = function(e) {
  cat(sprintf("Erro de conectividade: %s\n", e$message))
})


# =================================================================
# INVESTIGAÇÃO DE CÓDIGOS DE ESTATÍSTICA
# =================================================================
cat("\n=== PROCURANDO CÓDIGOS DE ESTATÍSTICA ===\n")
stat_variants <- dbGetQuery(conn, "SELECT code, name, abbreviation,
        (SELECT COUNT(*) FROM subject_memberships sm WHERE sm.subject_code = s.code) as oferecimentos
FROM subjects s
WHERE UPPER(s.name) LIKE '%STAT%'
    OR UPPER(s.abbreviation) LIKE '%STAT%'
   OR s.code = 'STAT'
ORDER BY oferecimentos DESC")
cat("Códigos relacionados a Estatística:\n")
print(stat_variants)

if (nrow(stat_variants) > 0 && stat_variants$oferecimentos[1] > 0) {
  codigo_estatistica <- stat_variants$code[1]
  cat(sprintf("\n Usando código: %s (%s) com %d oferecimentos\n",
              codigo_estatistica, stat_variants$name[1], stat_variants$oferecimentos[1]))
} else {
  cat("Nenhum código específico de estatística encontrado. Usando o mais comum para demonstração.\n")
  top_codes <- dbGetQuery(conn, "
  SELECT sm.subject_code, s.name, COUNT(*) as total
  FROM subject_memberships sm
  LEFT JOIN subjects s ON sm.subject_code = s.code
  GROUP BY sm.subject_code, s.name
  ORDER BY total DESC
  LIMIT 5
  ")
  print(top_codes)
  if (nrow(top_codes) > 0) {
    codigo_estatistica <- top_codes$subject_code[1]
    cat(sprintf("Usando código mais popular para demonstração: %s\n", codigo_estatistica))
  }
}

# =================================================================
# ATIVIDADE 1: PROFESSORES DE ESTATÍSTICA
# =================================================================
cat("\n=== PROFESSORES DE ESTATÍSTICA ===\n")
if (exists("codigo_estatistica")) {
  query_professores <- sprintf("
  SELECT DISTINCT
      i.name as professor_nome,
      i.id as professor_id,
      COUNT(DISTINCT co.uuid) as num_oferecimentos
  FROM instructors i
  INNER JOIN teachings t ON i.id = t.instructor_id
  INNER JOIN sections s ON t.section_uuid = s.uuid
  INNER JOIN course_offerings co ON s.course_offering_uuid = co.uuid
  INNER JOIN subject_memberships sm ON co.uuid = sm.course_offering_uuid
  WHERE sm.subject_code = '%s'
  GROUP BY i.name, i.id
  ORDER BY num_oferecimentos DESC, i.name
  ", codigo_estatistica)

  cat("Query sendo executada:\n")
  cat(query_professores, "\n\n")

  tryCatch({
    professores_stat <- dbGetQuery(conn, query_professores)

    if (nrow(professores_stat) > 0) {
      cat("SUCESSO! Professores encontrados:\n")
      print(kable(professores_stat)) # Exibe a tabela
      cat(sprintf("\n Total de professores: %d\n", nrow(professores_stat)))
    } else {
      cat("Nenhum professor encontrado para o código selecionado.\n")
    }
  }, error = function(e) {
    cat(sprintf("Erro na query: %s\n", e$message))
  })
}

# =================================================================
# ATIVIDADE 2: ANÁLISE DE GPA (MÉDIA DE NOTAS)
# =================================================================
cat("\n=== ANÁLISE DE GPA ===\n")
if (exists("codigo_estatistica")) {
    query_gpa <- sprintf("
    SELECT
        c.name as disciplina,
        c.number as numero,
        co.term_code,
        co.name as oferecimento_nome,
        CAST(COALESCE(gd.a_count, 0) AS INTEGER) as a_count,
        CAST(COALESCE(gd.ab_count, 0) AS INTEGER) as ab_count,
        CAST(COALESCE(gd.b_count, 0) AS INTEGER) as b_count,
        CAST(COALESCE(gd.bc_count, 0) AS INTEGER) as bc_count,
        CAST(COALESCE(gd.c_count, 0) AS INTEGER) as c_count,
        CAST(COALESCE(gd.d_count, 0) AS INTEGER) as d_count,
        CAST(COALESCE(gd.f_count, 0) AS INTEGER) as f_count,
        (CAST(COALESCE(gd.a_count, 0) AS INTEGER) +
          CAST(COALESCE(gd.ab_count, 0) AS INTEGER) +
          CAST(COALESCE(gd.b_count, 0) AS INTEGER) +
          CAST(COALESCE(gd.bc_count, 0) AS INTEGER) +
          CAST(COALESCE(gd.c_count, 0) AS INTEGER) +
          CAST(COALESCE(gd.d_count, 0) AS INTEGER) +
          CAST(COALESCE(gd.f_count, 0) AS INTEGER)) as total_estudantes,
        CASE
           WHEN (CAST(COALESCE(gd.a_count, 0) AS INTEGER) +
                 CAST(COALESCE(gd.ab_count, 0) AS INTEGER) +
                 CAST(COALESCE(gd.b_count, 0) AS INTEGER) +
                 CAST(COALESCE(gd.bc_count, 0) AS INTEGER) +
                 CAST(COALESCE(gd.c_count, 0) AS INTEGER) +
                 CAST(COALESCE(gd.d_count, 0) AS INTEGER) +
                 CAST(COALESCE(gd.f_count, 0) AS INTEGER)) > 0
          THEN ROUND(
              (CAST(COALESCE(gd.a_count, 0) AS REAL) * 4.0 +
                CAST(COALESCE(gd.ab_count, 0) AS REAL) * 3.5 +
                CAST(COALESCE(gd.b_count, 0) AS REAL) * 3.0 +
                CAST(COALESCE(gd.bc_count, 0) AS REAL) * 2.5 +
                CAST(COALESCE(gd.c_count, 0) AS REAL) * 2.0 +
                CAST(COALESCE(gd.d_count, 0) AS REAL) * 1.0 +
                CAST(COALESCE(gd.f_count, 0) AS REAL) * 0.0) /
               (CAST(COALESCE(gd.a_count, 0) AS REAL) +
                CAST(COALESCE(gd.ab_count, 0) AS REAL) +
                CAST(COALESCE(gd.b_count, 0) AS REAL) +
                CAST(COALESCE(gd.bc_count, 0) AS REAL) +
                CAST(COALESCE(gd.c_count, 0) AS REAL) +
                CAST(COALESCE(gd.d_count, 0) AS REAL) +
                CAST(COALESCE(gd.f_count, 0) AS REAL)), 3)
          ELSE NULL
        END as gpa_medio
    FROM grade_distributions gd
    INNER JOIN course_offerings co ON gd.course_offering_uuid = co.uuid
    INNER JOIN courses c ON co.course_uuid = c.uuid
    INNER JOIN subject_memberships sm ON co.uuid = sm.course_offering_uuid
    WHERE sm.subject_code = '%s'
      AND (CAST(COALESCE(gd.a_count, 0) AS INTEGER) +
            CAST(COALESCE(gd.ab_count, 0) AS INTEGER) +
            CAST(COALESCE(gd.b_count, 0) AS INTEGER) +
            CAST(COALESCE(gd.bc_count, 0) AS INTEGER) +
            CAST(COALESCE(gd.c_count, 0) AS INTEGER) +
            CAST(COALESCE(gd.d_count, 0) AS INTEGER) +
            CAST(COALESCE(gd.f_count, 0) AS INTEGER)) > 0
    ORDER BY gpa_medio ASC
    ", codigo_estatistica)

    tryCatch({
      dados_gpa <- dbGetQuery(conn, query_gpa)

      if (nrow(dados_gpa) > 0) {
        cat("Dados de GPA calculados com sucesso!\n")
        cat(sprintf("Total de oferecimentos analisados: %d\n", nrow(dados_gpa)))

        cat("\nPrimeiros resultados (ordenados por dificuldade):\n")
        print(kable(head(dados_gpa, 10)))

        gpas_validos <- dados_gpa$gpa_medio[!is.na(dados_gpa$gpa_medio)]
        if (length(gpas_validos) > 0) {
          # Usa o R para encontrar os índices min/max
          idx_min <- which.min(gpas_validos)
          idx_max <- which.max(gpas_validos)
          
          # Ajusta o índice de volta para o data.frame completo para pegar as informações da disciplina
          dados_gpa_validos <- dados_gpa[!is.na(dados_gpa$gpa_medio), ]
          
          disciplina_dificil <- dados_gpa_validos[idx_min, ]
          disciplina_facil <- dados_gpa_validos[idx_max, ]

          cat("\nEstatísticas de GPA:\n")
          cat(sprintf("• GPA mais baixo: %.3f\n", min(gpas_validos)))
          cat(sprintf("• GPA mais alto: %.3f\n", max(gpas_validos)))
          cat(sprintf("• GPA médio: %.3f\n", mean(gpas_validos)))

          cat(sprintf("\n DISCIPLINA MAIS DIFÍCIL: %s %s (GPA: %.3f)\n",
                      disciplina_dificil$numero, disciplina_dificil$disciplina, disciplina_dificil$gpa_medio))
          cat(sprintf("DISCIPLINA MAIS FÁCIL: %s %s (GPA: %.3f)\n",
                      disciplina_facil$numero, disciplina_facil$disciplina, disciplina_facil$gpa_medio))
        }
      } else {
        cat("Nenhum dado de GPA encontrado.\n")
      }
    }, error = function(e) {
      cat(sprintf("Erro na análise GPA: %s\n", e$message))
    })
}


# =================================================================
# ATIVIDADE 3: RANKING DE PROFESSORES POR GPA
# =================================================================
cat("\n=== RANKING DE PROFESSORES POR GPA ===\n")
if (exists("codigo_estatistica")) {
  query_ranking <- sprintf("
  SELECT
      i.name AS professor_nome,
      COUNT(DISTINCT gd.course_offering_uuid) AS num_oferecimentos,
      ROUND(AVG(
        CASE
           WHEN (COALESCE(gd.a_count,0) + COALESCE(gd.ab_count,0) + COALESCE(gd.b_count,0) +
                 COALESCE(gd.bc_count,0) + COALESCE(gd.c_count,0) + COALESCE(gd.d_count,0) +
                 COALESCE(gd.f_count,0)) > 0
          THEN
            (COALESCE(gd.a_count,0)*4.0 + COALESCE(gd.ab_count,0)*3.5 + COALESCE(gd.b_count,0)*3.0 +
              COALESCE(gd.bc_count,0)*2.5 + COALESCE(gd.c_count,0)*2.0 + COALESCE(gd.d_count,0)*1.0 +
              COALESCE(gd.f_count,0)*0.0) /
            (COALESCE(gd.a_count,0) + COALESCE(gd.ab_count,0) + COALESCE(gd.b_count,0) +
              COALESCE(gd.bc_count,0) + COALESCE(gd.c_count,0) + COALESCE(gd.d_count,0) +
              COALESCE(gd.f_count,0))
          ELSE NULL
        END
      ), 3) AS gpa_medio_professor,
      SUM(COALESCE(gd.a_count,0) + COALESCE(gd.ab_count,0) + COALESCE(gd.b_count,0) +
           COALESCE(gd.bc_count,0) + COALESCE(gd.c_count,0) + COALESCE(gd.d_count,0) +
           COALESCE(gd.f_count,0)) AS total_estudantes_ensinados
  FROM grade_distributions gd
  INNER JOIN course_offerings co ON gd.course_offering_uuid = co.uuid
  INNER JOIN subject_memberships sm ON co.uuid = sm.course_offering_uuid
  INNER JOIN sections s ON co.uuid = s.course_offering_uuid
  INNER JOIN teachings t ON s.uuid = t.section_uuid
  INNER JOIN instructors i ON t.instructor_id = i.id
  WHERE sm.subject_code = '%s'
  GROUP BY i.name, i.id
  HAVING COUNT(DISTINCT gd.course_offering_uuid) >= 1
  ORDER BY gpa_medio_professor ASC
  ", codigo_estatistica)

  tryCatch({
    ranking_professores <- dbGetQuery(conn, query_ranking)

    if (nrow(ranking_professores) > 0) {
      cat("RANKING CALCULADO:\n")
      # Filtra linhas com GPA válido para ranking min/max
      ranking_valido <- ranking_professores[!is.na(ranking_professores$gpa_medio_professor) & 
                                            ranking_professores$total_estudantes_ensinados > 0, ]
                                            
      print(kable(ranking_professores))

      if(nrow(ranking_valido) > 0) {
        idx_min <- which.min(ranking_valido$gpa_medio_professor)
        idx_max <- which.max(ranking_valido$gpa_medio_professor)

        professor_dificil <- ranking_valido[idx_min, ]
        professor_facil   <- ranking_valido[idx_max, ]

        cat("\n Professor considerado MAIS DIFÍCIL (menor GPA médio):\n")
        cat(sprintf("- %s (GPA médio = %.3f, N. Oferecimentos = %d)\n",
                    professor_dificil$professor_nome, professor_dificil$gpa_medio_professor, professor_dificil$num_oferecimentos))

        cat("\n Professor considerado MAIS FÁCIL (maior GPA médio):\n")
        cat(sprintf("- %s (GPA médio = %.3f, N. Oferecimentos = %d)\n",
                    professor_facil$professor_nome, professor_facil$gpa_medio_professor, professor_facil$num_oferecimentos))
      } else {
         cat("Nenhum professor com dados de notas válidos para o ranking de GPA.\n")
      }

    } else {
      cat(" Nenhum professor encontrado com dados suficientes.\n")
    }
  }, error = function(e) {
    cat(sprintf("Erro no ranking: %s\n", e$message))
  })
}

# =================================================================
# FINALIZAÇÃO
# =================================================================
dbDisconnect(conn)
cat("\nConexão com o banco de dados encerrada.\n")

```
